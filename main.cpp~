#include <iostream>
#include <fstream>
#include <random>

template<typename T>
vector<vector<T>>& getDataVector(std::string filename){
  std::ifstream reading_file;
  reading_file.open(filename,std::ios::in);
  std::string reading_line_buffer;
  std::cout << "reading" << filename << "…" << std::endl;
  T num;
  char comma;

  while(!reading_file.eof()){
    std::vector<T> temp_data;
    getline(reading_file,reading_line_buffer);
    std::istringstream is(reading_line_buffer);
    while(!is.eof()){
      is >> num >> comma;
      temp_data.push_back(num);
    }
    std::vector<vector<T>> data;
    data.push_back(temp_data);
  }
  return data;
}

template<typename T>
class RBM{
protected:
  std::vector<vector<T>> potential;
public:
  RBM(std::size_t layernum, std::vector<T> initialValue);
};

template<typename T>
RBM<T>::RBM(std::size_t layernum, std::vector<T> initialValue){
  potential.push_back(initialValue);
  for(std::size_t i = 1; i < layernum; ++i){
    std::vector<T> hiddenLayer(initialValue.size());
    potential.push_back(hiddenLayer)
  }
}

template<typename T>
void RBM<T>::setVisiblePotentials(vector<T>){
  
}

int main(){
  std::vector<vector<int>> sample = getDataVector(data.csv); //☓◯△□ ■●▲の順に１００次元ベクターに読み込む
  std::size_t nodenum = 100;
  std::size_t layernum = 2;

  return 0;
}
